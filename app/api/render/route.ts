// app/api/render/route.ts
// HTML-based document generation using OOXML+IA Pipeline
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { htmlGenerator } from '../../../lib/html-generator';
import { log } from '@/lib/logger';
import { promises as fs } from 'fs';
import path from 'path';

interface RenderRequest {
  templateId: string;
  documents: Array<{
    data: Record<string, any>;
    fileName: string;
  }>;
  outputFormat?: 'html' | 'pdf' | 'docx';
  instructions?: string;
}

interface RenderResponse {
  success: boolean;
  documents?: Array<{
    fileName: string;
    content: string;
    downloadUrl?: string;
  }>;
  error?: string;
  details?: string;
}

export async function POST(request: NextRequest): Promise<NextResponse<RenderResponse>> {
  const startTime = Date.now();
  log.debug('üé® HTML Render Request Started');
  
  try {
    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
    
    if (!supabaseUrl || !supabaseServiceKey) {
      log.error('‚ùå Supabase environment variables missing');
      return NextResponse.json({
        success: false,
        error: 'Storage configuration required'
      }, { status: 500 });
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);
    log.debug('‚úÖ Supabase client initialized for rendering');

    // Parse request data
    const { 
      templateId, 
      documents, 
      outputFormat = 'html',
      instructions 
    }: RenderRequest = await request.json();
    
    log.debug('üé® Render request:', {
      templateId,
      documentsCount: documents?.length || 0,
      outputFormat,
      hasInstructions: !!instructions
    });

    // Validation
    if (!templateId || !documents || !Array.isArray(documents) || documents.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'Missing required fields: templateId, documents array'
      }, { status: 400 });
    }

    // 1. Retrieve OOXML analysis data and style manifest from database
    log.debug('üìä Retrieving template data for:', templateId);
    
    const { data: templateData, error: dbError } = await supabase
      .from('templates')
      .select('*')
      .eq('template_id', templateId)
      .single();
      
    if (dbError || !templateData) {
      log.error('‚ùå Template not found:', dbError);
      return NextResponse.json({
        success: false,
        error: 'Template not found',
        details: dbError?.message
      }, { status: 404 });
    }

    log.debug('‚úÖ Template data retrieved:', {
      hasStyleManifest: !!templateData.style_manifest,
      hasHtmlContent: !!templateData.html_content,
      parsingVersion: templateData.parsing_version
    });

    // 2. Process each document
    const renderedDocuments = [];
    
    for (let i = 0; i < documents.length; i++) {
      const doc = documents[i];
      const docStartTime = Date.now();
      
      try {
        log.debug(`üé® Rendering document ${i + 1}/${documents.length}: ${doc.fileName}`);
        
        // 2.1. Generate HTML using semantic HTML generator
        const generationResult = await htmlGenerator.generateSemanticHTML(
          doc.data,
          templateData.style_manifest || undefined
        );
        
        let finalContent = generationResult.html;
        
        // 2.2. Apply AI instructions if provided
        if (instructions && instructions.trim()) {
          log.debug('üß† Applying AI instructions...');
          // For now, just add instructions as a comment - could be enhanced with AI processing
          finalContent = `<!-- AI Instructions: ${instructions} -->\n${finalContent}`;
        }
        
        // 2.3. Handle different output formats
        let renderedContent = finalContent;
        let contentType = 'text/html';
        
        if (outputFormat === 'pdf') {
          // Future: Convert HTML to PDF using puppeteer or similar
          log.debug('‚ö†Ô∏è PDF conversion not yet implemented, returning HTML');
          contentType = 'text/html';
        } else if (outputFormat === 'docx') {
          // Future: Use docxtemplater PRO with HTML module
          log.debug('‚ö†Ô∏è DOCX conversion not yet implemented, returning HTML');
          contentType = 'text/html';
        }
        
        const docProcessTime = Date.now() - docStartTime;
        
        renderedDocuments.push({
          fileName: doc.fileName.replace(/\.[^/.]+$/, '') + (outputFormat === 'html' ? '.html' : `.${outputFormat}`),
          content: renderedContent,
          // downloadUrl could be generated by saving to storage
        });
        
        log.debug(`‚úÖ Document ${i + 1} rendered in ${docProcessTime}ms`);
        
      } catch (docError) {
        log.error(`‚ùå Failed to render document ${i + 1}:`, docError);
        // Continue with other documents, but log the error
        renderedDocuments.push({
          fileName: doc.fileName + '.error.html',
          content: `<html><body><h1>Render Error</h1><p>${docError instanceof Error ? docError.message : 'Unknown error'}</p></body></html>`
        });
      }
    }

    const totalProcessTime = Date.now() - startTime;
    
    log.debug('‚úÖ Render operation complete:', {
      totalDocuments: documents.length,
      successfulRenders: renderedDocuments.filter(d => !d.fileName.includes('.error.')).length,
      totalProcessTime: totalProcessTime + 'ms',
      avgPerDocument: Math.round(totalProcessTime / documents.length) + 'ms'
    });

    return NextResponse.json({
      success: true,
      documents: renderedDocuments
    });

  } catch (error) {
    log.error('‚ùå Render operation failed:', error);
    return NextResponse.json({
      success: false,
      error: 'Render operation failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}